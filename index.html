<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Robot Simulator!</title>
	<style>
		#container {
			display: flex;
		}

		#grid {
			display: grid;
			grid-template-columns: repeat(30, 20px);
			gap: 2px;
			flex: 1;
		}

		#log {
			flex: 1;
			padding: 10px;
			border-left: 1px solid black;
			overflow-y: auto; /* To make it scrollable if there are many logs */
		}
		
		#log ul {
			list-style-type: none;
			padding: 0;
		}

		.cell {
			width: 20px;
			height: 20px;
			border: 1px solid black;
			cursor: pointer;
			display: flex;           /* Enable flexbox */
			justify-content: center; /* Center content horizontally */
			align-items: center;     /* Center content vertically */
		}

		.cell[data-type="1"] {
			background-color: white;
		}

		.cell[data-type="0"] {
			background-color: black;
		}

		.cell[data-type="start"] {
			background-color: green;
		}

		.cell[data-type="end"] {
			background-color: red;
		}

		.cell[data-path="true"] {
			border: 3px solid blue;
		}
	</style>
</head>

<body>
	<div id="container">
		<div id="grid"></div>
		<div id="log">
			<h3>Event Log <button id="exportLog">Export Log</button></h3>
			<ul></ul>
		</div>
	</div>
	
	<button id="inference">Run Simulation</button>
	<button id="setDefaultStartEnd">Default Starting (5,5) / Ending (38,28)</button>
	<button id="findPath">Find Ideal Path (Dijkstra)</button>
	<br>
	<button onclick="generateObstacles(0.10)">10% Obstacles</button>
	<button onclick="generateObstacles(0.20)">20% Obstacles</button>
	<button onclick="generateObstacles(0.45)">45% Obstacles</button>
	<br>
	<button id="reset">Reset Everything</button>
	<button id="resetStart">Reset Start</button>
	<button id="resetEnd">Reset End</button>

	<br>
	<button id="exportGrid">Export Grid to File</button>
	<input type="file" id="fileInput">
	<button id="importGrid">Import Grid from File</button>


	<script>
		const m = 40;
		const n = 30;
		let direction = 0; // means facing upwards by default
		let grid = Array(m).fill().map(() => Array(n).fill(1));
		let start = null;
		let end = null;

		function renderGrid() {
			const gridDiv = document.getElementById('grid');
			gridDiv.innerHTML = '';

			for (let i = 0; i < m; i++) {
				for (let j = 0; j < n; j++) {
					const cell = document.createElement('div');
					cell.className = 'cell';
					cell.dataset.type = grid[i][j];
					cell.dataset.row = i;
					cell.dataset.col = j;
					if (start && start[0] === i && start[1] === j) {
						cell.dataset.type = 'start';
						cell.innerHTML = getArrowForDirection(direction);
					}
					if (end && end[0] === i && end[1] === j) {
						cell.dataset.type = 'end';
					}
					cell.onclick = () => toggleCell(i, j);
					gridDiv.appendChild(cell);
				}
			}
		}

		function getArrowForDirection(direction) {
			switch (direction) {
				case 0: return '↑';
				case 45: return '↗';
				case 90: return '→';
				case 135: return '↘';
				case 180: return '↓';
				case 225: return '↙';
				case 270: return '←';
				case 315: return '↖';
				default: return '';
			}
		}

		function logEvent(message) {
			const currentTime = new Date();
			const timestamp = currentTime.toLocaleTimeString();

			const logList = document.querySelector('#log ul');
			const listItem = document.createElement('li');
			listItem.textContent = `[${timestamp}] ${message}`;
			
			logList.appendChild(listItem);
		}

		function toggleCell(i, j) {
			// Create mutual exclusion of start cell and end cell
			if (start && start[0] === i && start[1] === j) {
				// user just clicked on the start cell (again)
				direction = (direction + 45) % 360;

				logEvent(`Updated start direction to ${direction}`);
				renderGrid();
				return;
			}
			if (end && end[0] === i && end[1] === j) {
				// User just clicked end again
				end = null;
				logEvent(`User removed end/goal`);
				renderGrid();
				return;
			}

			// Assign the cell to the correct type
			if (!start) {
				start = [i, j];
				logEvent(`User set start to (${i},${j})`);
			} else if (!end) {
				end = [i, j];
				logEvent(`User set end/goal to (${i},${j})`);
			} else {
				grid[i][j] = grid[i][j] === 1 ? 0 : 1;
			}
			renderGrid();
		}

		function generateObstacles(percentage) {
			for (let i = 0; i < m; i++) {
				for (let j = 0; j < n; j++) {
					if (Math.random() < percentage) {
						grid[i][j] = 0;
					} else {
						grid[i][j] = 1;
					}
				}
			}
			logEvent(`User generated random map with ${percentage*100}% Obstacles`);
			renderGrid();
		}

		document.getElementById('findPath').onclick = findPath;

		function findPath() {
			if (!start || !end) {
				logEvent('(Dijkstra) Please set both start and end points.');
				return;
			}

			const distance = Array(m).fill().map(() => Array(n).fill(Infinity));
			const visited = Array(m).fill().map(() => Array(n).fill(false));
			const queue = [[...start, 0]];

			distance[start[0]][start[1]] = 0;

			while (queue.length) {
				queue.sort((a, b) => a[2] - b[2]);
				const [x, y, d] = queue.shift();

				if (visited[x][y]) continue;
				visited[x][y] = true;

				for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
					const nx = x + dx;
					const ny = y + dy;

					if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny] && grid[nx][ny] !== 0) {
						const newDist = d + 1;
						if (newDist < distance[nx][ny]) {
							distance[nx][ny] = newDist;
							queue.push([nx, ny, newDist]);
						}
					}
				}
			}

			if (distance[end[0]][end[1]] === Infinity) {
				logEvent('(Dijkstra) No path found!!!!');
			} else {
				logEvent('(Dijkstra) Highlighting Path Found! Shortest path length: ' + distance[end[0]][end[1]]);
				backtrackPath(start, end, distance);
			}
		}

		function backtrackPath(start, end, distance) {
			let [x, y] = end;
			while (x !== start[0] || y !== start[1]) {
				document.querySelector(`.cell[data-row="${x}"][data-col="${y}"]`).dataset.path = "true";
				let minDist = Infinity;
				let nextStep = null;
				for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
					const nx = x + dx;
					const ny = y + dy;
					if (nx >= 0 && ny >= 0 && nx < m && ny < n && distance[nx][ny] < minDist) {
						minDist = distance[nx][ny];
						nextStep = [nx, ny];
					}
				}
				[x, y] = nextStep;
			}
		}

		document.getElementById('exportLog').onclick = function() {
			const logEntries = Array.from(document.querySelectorAll('#log li'));
			const logText = logEntries.map(entry => entry.textContent).join('\n');
			const blob = new Blob([logText], { type: "text/plain;charset=utf-8" });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);

			const currentTime = new Date();
			const timestamp = currentTime.toLocaleTimeString();

			a.download = `${timestamp}.log`;
			a.click();
		};

		document.getElementById('exportGrid').onclick = function() {
			const gridStateString = JSON.stringify(grid);
			const blob = new Blob([gridStateString], { type: "text/plain;charset=utf-8" });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = 'gridState.txt';
			a.click();
		};

		document.getElementById('importGrid').onclick = function() {
			const fileInput = document.getElementById('fileInput');
			const file = fileInput.files[0];
			if (file) {
				const reader = new FileReader();
				reader.onload = function(event) {
					try {
						const importedGrid = JSON.parse(event.target.result);
						if (Array.isArray(importedGrid) && importedGrid.length === m && importedGrid[0].length === n) {
							grid = importedGrid;
							renderGrid();
							logEvent(`Grid state imported successfully from ${file.name}`);
						} else {
							logEvent("Invalid grid state");
						}
					} catch (error) {
						logEvent("Error parsing grid state");
					}
				};
				reader.readAsText(file);
			} else {
				logEvent("No file selected");
			}
		};

		document.getElementById('setDefaultStartEnd').onclick = setDefaultStartEnd;
		document.getElementById('reset').onclick = resetGrid;
		document.getElementById('resetStart').onclick = resetStart;
		document.getElementById('resetEnd').onclick = resetEnd;

		function resetGrid() {
			grid = Array(m).fill().map(() => Array(n).fill(1));
			start = null;
			end = null;
			logEvent("Removed everything!");
			renderGrid();
		}

		function resetStart() {
			if(start)
				logEvent("Removed start point & orientation");
			direction = 0;
			start = null;
			renderGrid();
		}

		function resetEnd() {
			if(end)
				logEvent("Removed end point / goal");
			end = null;
			renderGrid();
		}

		function setDefaultStartEnd() {
			direction = 0;
			start = [5, 5];
			end = [38, 28];

			logEvent("Defaulting start and end points set to (5,5) and (38,28)");
			
			renderGrid();
		}

		renderGrid();
		logEvent("Finished Init! Go ahead and click cells or control buttons")
	</script>
</body>

</html>