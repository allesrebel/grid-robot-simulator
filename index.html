<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Robot Simulator!</title>
	<style>
		#container {
			display: flex;
			height: 100vh;
		}

		#grid {
			display: grid;
			grid-template-columns: repeat(40, 20px);
			flex: 1;
			overflow: auto;
		}

		#log {
			flex: 1;
			padding: 10px;
			border-left: 1px solid black;
			overflow-y: auto; /* To make it scrollable if there are many logs */
			max-height: 100vh;
		}
		
		#log ul {
			list-style-type: none;
			padding: 0;
		}

		.cell {
			width: 20px;
			height: 20px;
			margin: 0; /* Ensure no margin */
			border: 1px solid black;
			cursor: pointer;
			display: flex;           /* Enable flexbox */
			justify-content: center; /* Center content horizontally */
			align-items: center;     /* Center content vertically */
		}

		.cell[data-type="1"] {
			background-color: white;
		}

		.cell[data-type="0"] {
			background-color: black;
		}

		.cell[data-type="start"] {
			background-color: green;
		}

		.cell[data-type="end"] {
			background-color: red;
		}

		.cell[data-path="true"] {
			border: thick;
			background: blue;
		}
	</style>
</head>

<body>
	<div id="container">
		<div id="grid"></div>
		<div id="log">
			<div id="controls">
				<button id="startSimulation">Run Simulation</button>
				<button id="setDefaultStartEnd">Default Starting (5,5) / Ending (38,28)</button>
				<button id="findPath">Find Ideal Path (Dijkstra)</button>
				<br>
				<button onclick="generateObstacles(0.10)">10% Obstacles</button>
				<button onclick="generateObstacles(0.20)">20% Obstacles</button>
				<button onclick="generateObstacles(0.45)">45% Obstacles</button>
				<br>
				<button id="reset">Reset Everything</button>
				<button id="resetStart">Reset Start</button>
				<button id="resetEnd">Reset End</button>
			
				<br>
				<button id="exportGrid">Export Grid to File</button>
				<input type="file" id="fileInput">
				<button id="importGrid">Import Grid from File</button>
			</div>
			<h3>Event Log <button id="exportLog">Export Log</button></h3>
			<ul></ul>
		</div>
	</div>

	<script>
		let grid = Array(m).fill().map(() => Array(n).fill(1));

		// The Data Base for the Robot
		let direction = 0; // means facing upwards by default
		let memory = Array(m).fill().map(() => Array(n).fill(-1));
		const n = 40; // note n and m are flipped because we do row first
		const m = 30; // then column in this program, either way, it produces 0-39 range for X
		let start = null;
		let end = null;
		let current_position = null;

		// Next Move output from engine
		const queue = [{ x: start[0], y: start[1], dist: 0 }];	// for next move!


		function renderGrid() {
			const gridDiv = document.getElementById('grid');
			gridDiv.innerHTML = '';

			for (let i = 0; i < m; i++) {
				for (let j = 0; j < n; j++) {
					const cell = document.createElement('div');
					cell.className = 'cell';
					cell.dataset.type = grid[i][j];
					cell.dataset.row = i;
					cell.dataset.col = j;
					if (start && start[0] === i && start[1] === j) {
						cell.dataset.type = 'start';
						cell.innerHTML = getArrowForDirection(direction);
					}
					if (end && end[0] === i && end[1] === j) {
						cell.dataset.type = 'end';
					}
					cell.onclick = () => toggleCell(i, j);
					gridDiv.appendChild(cell);
				}
			}
		}

		// function to handle the robot scanning using it's sensors
		// this assumes that the dx,dy is set correctly
		function scanAhead(x, y, dx, dy) {
			while (true) {
				x += dx;
				y += dy;

				if (x < 0 || x >= m || y < 0 || y >= n) {
					// Out of bounds
					break;
				}

				if (grid[x][y] === 0) {
					// Obstruction detected
					memory[x][y] = 0;
					break;
				} else {
					memory[x][y] = 1; // open
				}
			}
		}

		function startSimulation() {
			// Check preconditions
			if(!start || !end)
			{
				logEvent('(Simulation) Missing start and end points!');
				return;
			}

			function getDeltas(direction)
			{
				logEvent(`processing raw ${direction}`)
				if( direction < 0 )
					direction = 360 + direction;

				logEvent(`processing pos ${direction}`)
				direction = direction % 360;

				logEvent(`processing ${direction}`)
				switch (direction) {
					case 0: return [-1, 0];//'↑';
					case 45: return [-1, 1];//'↗';
					case 90: return [0, 1];//'→';
					case 135: return [1, 1];//'↘';
					case 180: return [1, 0];//'↓';
					case 225: return [1, -1];//'↙';
					case 270: return [0, -1];//'←';
					case 315: return [-1, -1];//'↖';
					default: return null;
				}
			}

			////////
			// Initialization
			// before performing simulation, initialize the memory
			// 0 = obstacle, 1 = free, 2 = unknown
			memory = Array(m).fill().map(() => Array(n).fill(2));

			// Shade Memory for Start / End with Blocked 
			memory[start[0]][start[1]] = 0;
			memory[end[0]][end[1]] = 0;
			current_position = start;
			const visited = Array(m).fill().map(() => Array(n).fill(false));
			////////

			// our path finding algo to generate next cell
			// based on database
			function dijkstraShortestPath() {
				const distance = Array(m).fill().map(() => Array(n).fill(Infinity));
				const directions = [getDeltas(direction), getDeltas(direction - 45), getDeltas(direction + 45), getDeltas(direction + 45 * 4)];

				distance[start[0]][start[1]] = 0;

				const current = queue.shift();
				if (!visited[current.x][current.y]) return;
				visited[current.x][current.y] = true;

				for (const dir of directions) {
					const newX = current.x + dir[0];
					const newY = current.y + dir[1];

					if (newX >= 0 && newX < n && newY >= 0 && newY < m && !visited[newX][newY] && memory[newX][newY] == 1) {
						const newDist = current.dist + 1;
						if (newDist < distance[newX][newY]) {
							distance[newX][newY] = newDist;
							queue.push({ x: newX, y: newY, dist: newDist });
						}
					}
				}

				// Return the distance matrix
				return distance;
			}

			let stopped = false;
			while(!stopped)
			{
				//// Perform Scan based on current location
				// Determine the current direction index based on direction
				const forward = getDeltas( direction );
				const leftDir = getDeltas( direction - 45 );  // 45 degrees to the left
				const rightDir = getDeltas( direction + 45 );  // 45 degrees to the right

				// Scan straight ahead
				scanAhead(current_position[0], current_position[1], forward[0], forward[1]);
				// Scan to the left
				scanAhead(current_position[0], current_position[1], leftDir[0], leftDir[1]);
				// Scan to the right
				scanAhead(current_position[0], current_position[1], rightDir[0], rightDir[1]);
				////

				// determine next action using rules
				// and database (forward/backward chaining)
				// of the three possible actions, we choose one
				// either:
				// * we move forward into one of the three cells
				// * rotate left or right 
				// * move backwards one cell
				// Backwards chaining - starting from the goal
				// have we seen the cells near it?
				// 	then -> queue 
				// we we haven't queued anything. Let's rotate
			

				// movement rule -> if next move doesn't hit the bounds or hit a wall
					// doesn't matter if it's forward 3 or back 1
				// perform the action

				// rotation rule -> if next move is a rotation, perform it

				// log the event to database for next round
				// print memory to log

				// Optionally, render the memory to visualize it
				renderMemory();

				// completion rule -> do we have a move at all in the queue?

			}
		}

		function renderMemory() {
			// This function can visualize the memory on the grid for debugging purposes
			for (let i = 0; i < m; i++) {
				for (let j = 0; j < n; j++) {
					const cell = document.querySelector(`.cell[data-row="${i}"][data-col="${j}"]`);
					if (memory[i][j] === 1) {
						// 1 means open cell
						cell.style.backgroundColor = 'purple';
					} else if (memory[i][j] === 0) {
						// 0 means blocked cell
						cell.style.opacity = 0.5;
					}
				}
			}
		}

		function getArrowForDirection(direction) {
			switch (direction) {
				case 0: return '↑';
				case 45: return '↗';
				case 90: return '→';
				case 135: return '↘';
				case 180: return '↓';
				case 225: return '↙';
				case 270: return '←';
				case 315: return '↖';
				default: return '';
			}
		}

		function logEvent(message) {
			const currentTime = new Date();
			const timestamp = currentTime.toLocaleTimeString();

			const logList = document.querySelector('#log ul');
			const listItem = document.createElement('li');
			listItem.textContent = `[${timestamp}] ${message}`;
			
			logList.appendChild(listItem);
			const logContainer = document.getElementById('log');
			logContainer.scrollTop = logContainer.scrollHeight;
		}

		function toggleCell(i, j) {
			// Create mutual exclusion of start cell and end cell
			if (start && start[0] === i && start[1] === j) {
				// user just clicked on the start cell (again)
				direction = (direction + 45) % 360;

				logEvent(`Updated start direction to ${direction}`);
				renderGrid();
				return;
			}
			if (end && end[0] === i && end[1] === j) {
				// User just clicked end again
				end = null;
				logEvent(`User removed end/goal`);
				renderGrid();
				return;
			}

			// Assign the cell to the correct type
			if (!start) {
				start = [i, j];
				logEvent(`User set start to (${j}, ${i})`);
			} else if (!end) {
				end = [i, j];
				logEvent(`User set end/goal to (${j},${i})`);
			} else {
				grid[i][j] = grid[i][j] === 1 ? 0 : 1;
			}
			renderGrid();
		}

		function generateObstacles(percentage) {
			for (let i = 0; i < m; i++) {
				for (let j = 0; j < n; j++) {
					if (Math.random() < percentage) {
						grid[i][j] = 0;
					} else {
						grid[i][j] = 1;
					}
				}
			}
			logEvent(`User generated random map with ${percentage*100}% Obstacles`);
			renderGrid();
		}

		document.getElementById('findPath').onclick = findPath;

		function findPath() {
			if (!start || !end) {
				logEvent('(Dijkstra) Please set both start and end points.');
				return;
			}

			const distance = Array(m).fill().map(() => Array(n).fill(Infinity));
			const visited = Array(m).fill().map(() => Array(n).fill(false));
			const queue = [[...start, 0]];

			distance[start[0]][start[1]] = 0;

			while (queue.length) {
				queue.sort((a, b) => a[2] - b[2]);
				const [x, y, d] = queue.shift();

				if (visited[x][y]) continue;
				visited[x][y] = true;

				for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
					const nx = x + dx;
					const ny = y + dy;

					if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny] && grid[nx][ny] !== 0) {
						const newDist = d + 1;
						if (newDist < distance[nx][ny]) {
							distance[nx][ny] = newDist;
							queue.push([nx, ny, newDist]);
						}
					}
				}
			}

			if (distance[end[0]][end[1]] === Infinity) {
				logEvent('(Dijkstra) No path found!!!!');
			} else {
				logEvent('(Dijkstra) Highlighting Path Found! Shortest path length: ' + distance[end[0]][end[1]]);
				backtrackPath(start, end, distance);
			}
		}

		function backtrackPath(start, end, distance) {
			let [x, y] = end;
			while (x !== start[0] || y !== start[1]) {
				if(!(x == end[0] && y == end[1]))
					document.querySelector(`.cell[data-row="${x}"][data-col="${y}"]`).dataset.path = "true";
				let minDist = Infinity;
				let nextStep = null;
				for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
					const nx = x + dx;
					const ny = y + dy;
					if (nx >= 0 && ny >= 0 && nx < m && ny < n && distance[nx][ny] < minDist) {
						minDist = distance[nx][ny];
						nextStep = [nx, ny];
					}
				}
				[x, y] = nextStep;
			}
		}

		document.getElementById('exportLog').onclick = function() {
			const logEntries = Array.from(document.querySelectorAll('#log li'));
			const logText = logEntries.map(entry => entry.textContent).join('\n');
			const blob = new Blob([logText], { type: "text/plain;charset=utf-8" });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);

			const currentTime = new Date();
			const timestamp = currentTime.toLocaleTimeString();

			a.download = `${timestamp}.log`;
			a.click();
		};

		document.getElementById('exportGrid').onclick = function() {
			const gridStateString = JSON.stringify(grid);
			const blob = new Blob([gridStateString], { type: "text/plain;charset=utf-8" });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);

			const currentTime = new Date();
			const timestamp = currentTime.toLocaleTimeString();

			a.download = `${timestamp}.grid`;
			a.click();
		};

		document.getElementById('importGrid').onclick = function() {
			const fileInput = document.getElementById('fileInput');
			const file = fileInput.files[0];
			if (file) {
				const reader = new FileReader();
				reader.onload = function(event) {
					try {
						const importedGrid = JSON.parse(event.target.result);
						if (Array.isArray(importedGrid) && importedGrid.length === m && importedGrid[0].length === n) {
							grid = importedGrid;
							renderGrid();
							logEvent(`Grid state imported successfully from ${file.name}`);
						} else {
							logEvent("Invalid grid state");
						}
					} catch (error) {
						logEvent("Error parsing grid state");
					}
				};
				reader.readAsText(file);
			} else {
				logEvent("No file selected");
			}
		};

		document.getElementById('startSimulation').onclick = startSimulation;
		document.getElementById('setDefaultStartEnd').onclick = setDefaultStartEnd;
		document.getElementById('reset').onclick = resetGrid;
		document.getElementById('resetStart').onclick = resetStart;
		document.getElementById('resetEnd').onclick = resetEnd;

		function resetGrid() {
			grid = Array(m).fill().map(() => Array(n).fill(1));
			start = null;
			end = null;
			logEvent("Removed everything!");
			renderGrid();
		}

		function resetStart() {
			if(start)
				logEvent("Removed start point & orientation");
			direction = 0;
			start = null;
			renderGrid();
		}

		function resetEnd() {
			if(end)
				logEvent("Removed end point / goal");
			end = null;
			renderGrid();
		}

		function setDefaultStartEnd() {
			direction = 0;
			start = [5, 5];
			end = [28, 38];

			logEvent("Defaulting start and end points set to (5,5) and (38,28)");
			
			renderGrid();
		}

		renderGrid();
		logEvent("Finished Init! Go ahead and click cells or control buttons")
	</script>
</body>

</html>